## Awake & Start

`Awake`在 `MonoBehavior` 创建后就立刻调用(不管脚本是不是 `enable` 的)，而且生命周期只会被调用一次. `Start` 将在 `MonoBehavior` 创建后在该帧 `Update` 之前，在该 `Monobehavior.enabled == true` 的情况下执行。

**不同对象的 awake 调用顺序是 Unity 自己分配的,不可控.**

`Start`在对象被第一次`enable`后,在`Update`之前调用, **只有脚本`enable`的状态来,`Start`才会被调用.**

尽量将其他 `Objec`t 的 `reference` 设置等事情放在 `Awake` 处理。然后将这些 `reference` 的 `Object` 的赋值设置放在 `Start()`中来完成。



## 单例模式的优缺点

单例是用来取代全局函数变量的(这样说比较好理解), 所以要用全局函数的情况就应该用单例,否则就不应该.

单例通常是全生命周期永不销毁的.如果做的不是全局功能,不应该用单例.

### 优点

- 单例模式中,活动的单例只有一个实例,对单例类的所有实例化得到的都是相同的一个实例.这样防止其它对象对自己的实例化,确保所有对象都访问一个实例
- 单例模式具有一定的伸缩性,类自己来控制实例化的进程
- 提供了对唯一实例的受控访问
- 系统内存中只存在一个对象,因此可以节约系统资源,当需要频繁创建和销毁的对象时单例模式无疑可以提高系统的性能
- 允许可变数目的实例
- 避免对共享资源的多重占用

### 缺点

- 不适用于变化的对象,如果同一类型的对象总是要在不同的用例场景发生变化,单例就会引起数据的错误,不能保存彼此的状态
- 由于单例模式中没有抽象层,因此单例类的扩展有很大困难
- 单例类的职责过重,在一定程度上违背了"单一职责原则”
- 滥用单例将带来一些负面问题,如为了节省资源将数据库连接池对象设计为的单例类,可能会导致共享连接池对象的程序过多而出现连接池溢出; 如果实例化的对象长时间不被利用,系统会认为是垃圾而被回收,这将导致对象状态的丢失

### 注意事项

- 使用时不能用反射模式创建单例,否则会实例化一个新的对象
- 需要调用上下文的实例最好不要做成单例,例如边玩边更新,重放,断线重连

### 适用场景

- 需要频繁实例化然后销毁的对象
- 创建对象时耗时过多或耗资源过多,但又经常用到的对象
- 有状态的工具类对象
- 频繁访问数据库或文件的对象

## 动画播放的性能

- 尽量用 `prefab` ，尽量少用图片模拟简单动画，例如转向
- 某些只播放一次的动画，例如爆炸或出生特效，放在角色下面成为子物体，调用次数会少

## FindObject的性能

- `GameObject.Find()`
  - 通过名称, 如果物品active是false的话,找不到
  - 使用递归方法,非常耗性能,尽量少用,不要在Update里用
- `Transform.Find()`
  - 先用GameObject.Find找到父对象, 再用transform.Find找子对象
  - 可以查找隐藏对象, 必须保证顶级父对象active是true
  - 找孙对象 `father.transform.Find(“son/grandson”).gameObject;`
- `GameObject.FindObjectOfType`
  - 按物体身上挂载的组件找, 同样用递归, 效率不高

## 类的性能

先判断是需要挂在物体上的组件,还是普通类.

如果是和组件无关,不要继承 `MonoBehaviour `,保持纯粹性, 减少性能消耗

如果属于组件,必须继承`MonoBehaviour`

## Update FixedUpdate LateUpdate

- 处理`Rigidbody`时需要用`FixedUpdate`代`替Update`,因为机器性能不同,会影响帧处理速度,用于`FixedUpdate`强制固定帧速率,保证动画速度一致
- `FixedUpdate`的时间间隔可以在 `Edit > ProjectSetting > time > Fixedtimestep` 中修改
- `LateUpdate`晚于`Update`调用,可用于控制同一物体身上的不同脚本,挂载`LateUpdate`的脚本晚于`Update`脚本执行,如果两个脚本中都有动画,在其中一个脚本使用`LateUpdate`可以防止动画在同一时间执行导致的抖动











![img](performance.assets/monobehaviour_flowchart.svg)